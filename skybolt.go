// Package skybolt provides high-performance asset caching for multi-page applications.
//
// It reads the render-map.json generated by @skybolt/vite-plugin and outputs
// optimized HTML tags with intelligent caching via Service Workers.
package skybolt

import (
	"encoding/json"
	"fmt"
	"html"
	"net/url"
	"os"
	"strings"
)

// Version is the current version of the Skybolt Go adapter.
const Version = "3.2.0"

// Asset represents a single asset in the render map.
type Asset struct {
	URL     string `json:"url"`
	Hash    string `json:"hash"`
	Size    int    `json:"size"`
	Content string `json:"content"`
}

// ClientConfig represents the client script configuration.
type ClientConfig struct {
	Script string `json:"script"`
}

// ServiceWorkerConfig represents the service worker configuration.
type ServiceWorkerConfig struct {
	Filename string `json:"filename"`
	Path     string `json:"path"`
}

// RenderMap represents the complete render map structure.
type RenderMap struct {
	Version        int                 `json:"version"`
	Generated      string              `json:"generated"`
	SkyboltVersion string              `json:"skyboltVersion"`
	BasePath       string              `json:"basePath"`
	Assets         map[string]Asset    `json:"assets"`
	Client         ClientConfig        `json:"client"`
	ServiceWorker  ServiceWorkerConfig `json:"serviceWorker"`
}

// Skybolt is the main struct for rendering assets.
type Skybolt struct {
	renderMap   RenderMap
	clientCache map[string]string
	cdnURL      string
}

// New creates a new Skybolt instance.
//
// renderMapPath is the path to render-map.json generated by the Vite plugin.
// cookies is a map of cookie name to value (can be nil).
// cdnURL is an optional CDN URL prefix (can be empty).
func New(renderMapPath string, cookies map[string]string, cdnURL string) (*Skybolt, error) {
	data, err := os.ReadFile(renderMapPath)
	if err != nil {
		return nil, fmt.Errorf("cannot read render map: %w", err)
	}

	var renderMap RenderMap
	if err := json.Unmarshal(data, &renderMap); err != nil {
		return nil, fmt.Errorf("invalid render map JSON: %w", err)
	}

	// Parse the sb_assets cookie
	clientCache := make(map[string]string)
	if cookies != nil {
		if sbAssets, ok := cookies["sb_assets"]; ok {
			clientCache = parseCookie(sbAssets)
		}
	}

	// Normalize CDN URL
	if cdnURL != "" {
		cdnURL = strings.TrimRight(cdnURL, "/")
	}

	return &Skybolt{
		renderMap:   renderMap,
		clientCache: clientCache,
		cdnURL:      cdnURL,
	}, nil
}

// CSS renders a CSS asset.
//
// On first visit: inlines CSS with sb-* attributes for caching.
// On repeat visit: outputs <link> tag (Service Worker serves from cache).
func (s *Skybolt) CSS(entry string) string {
	asset, ok := s.renderMap.Assets[entry]
	if !ok {
		return s.comment(fmt.Sprintf("Skybolt: asset not found: %s", entry))
	}

	assetURL := s.resolveURL(asset.URL)

	// Client has current version - external link (SW serves from cache)
	if s.hasCached(entry, asset.Hash) {
		return fmt.Sprintf(`<link rel="stylesheet" href="%s">`, html.EscapeString(assetURL))
	}

	// First visit - inline with cache attributes
	return fmt.Sprintf(
		`<style sb-asset="%s:%s" sb-url="%s">%s</style>`,
		html.EscapeString(entry),
		html.EscapeString(asset.Hash),
		html.EscapeString(assetURL),
		asset.Content,
	)
}

// Script renders a JavaScript asset.
//
// On first visit: inlines JS with sb-* attributes for caching.
// On repeat visit: outputs <script> tag (Service Worker serves from cache).
func (s *Skybolt) Script(entry string, module bool) string {
	asset, ok := s.renderMap.Assets[entry]
	if !ok {
		return s.comment(fmt.Sprintf("Skybolt: asset not found: %s", entry))
	}

	assetURL := s.resolveURL(asset.URL)
	typeAttr := ""
	if module {
		typeAttr = ` type="module"`
	}

	// Client has current version - external script (SW serves from cache)
	if s.hasCached(entry, asset.Hash) {
		return fmt.Sprintf(`<script%s src="%s"></script>`, typeAttr, html.EscapeString(assetURL))
	}

	// First visit - inline with cache attributes
	return fmt.Sprintf(
		`<script%s sb-asset="%s:%s" sb-url="%s">%s</script>`,
		typeAttr,
		html.EscapeString(entry),
		html.EscapeString(asset.Hash),
		html.EscapeString(assetURL),
		asset.Content,
	)
}

// Preload renders a preload link for critical resources.
//
// Use this for fonts, images, or other resources that should load early.
// Preloaded resources are not cached by Skybolt's Service Worker.
func (s *Skybolt) Preload(entry, asType, mimeType, crossorigin, fetchpriority string) string {
	// Try to resolve from assets, fall back to using entry as URL
	assetURL := s.GetAssetURL(entry)
	if assetURL == "" {
		assetURL = entry
	}
	assetURL = s.resolveURL(assetURL)

	attrs := []string{
		`rel="preload"`,
		fmt.Sprintf(`href="%s"`, html.EscapeString(assetURL)),
		fmt.Sprintf(`as="%s"`, html.EscapeString(asType)),
	}

	if mimeType != "" {
		attrs = append(attrs, fmt.Sprintf(`type="%s"`, html.EscapeString(mimeType)))
	}
	if crossorigin != "" {
		attrs = append(attrs, fmt.Sprintf(`crossorigin="%s"`, html.EscapeString(crossorigin)))
	}
	if fetchpriority != "" {
		attrs = append(attrs, fmt.Sprintf(`fetchpriority="%s"`, html.EscapeString(fetchpriority)))
	}

	return fmt.Sprintf("<link %s>", strings.Join(attrs, " "))
}

// LaunchScript renders the Skybolt client launcher.
//
// Call this once in <head> before other Skybolt assets.
// Outputs config meta tag and client script.
func (s *Skybolt) LaunchScript() string {
	swPath := s.renderMap.ServiceWorker.Path
	if swPath == "" {
		swPath = "/skybolt-sw.js"
	}

	config := map[string]string{"swPath": swPath}
	configJSON, _ := json.Marshal(config)

	return fmt.Sprintf(
		`<meta name="skybolt-config" content="%s">`+"\n"+`<script type="module">%s</script>`,
		html.EscapeString(string(configJSON)),
		s.renderMap.Client.Script,
	)
}

// GetAssetURL returns the URL for an asset (for manual use cases).
// Returns empty string if not found.
func (s *Skybolt) GetAssetURL(entry string) string {
	asset, ok := s.renderMap.Assets[entry]
	if !ok {
		return ""
	}
	return s.resolveURL(asset.URL)
}

// GetAssetHash returns the hash for an asset (for manual use cases).
// Returns empty string if not found.
func (s *Skybolt) GetAssetHash(entry string) string {
	asset, ok := s.renderMap.Assets[entry]
	if !ok {
		return ""
	}
	return asset.Hash
}

// resolveURL resolves a URL with optional CDN prefix.
func (s *Skybolt) resolveURL(assetURL string) string {
	if s.cdnURL == "" {
		return assetURL
	}

	// Don't prefix absolute URLs
	if strings.HasPrefix(assetURL, "http://") ||
		strings.HasPrefix(assetURL, "https://") ||
		strings.HasPrefix(assetURL, "//") {
		return assetURL
	}

	return s.cdnURL + assetURL
}

// hasCached checks if client has a specific asset version cached.
func (s *Skybolt) hasCached(entry, hash string) bool {
	cachedHash, ok := s.clientCache[entry]
	return ok && cachedHash == hash
}

// parseCookie parses the sb_assets cookie into a name => hash map.
func parseCookie(cookie string) map[string]string {
	if cookie == "" {
		return make(map[string]string)
	}

	decoded, err := url.QueryUnescape(cookie)
	if err != nil {
		decoded = cookie
	}

	cache := make(map[string]string)
	for _, pair := range strings.Split(decoded, ",") {
		// Find last colon (hash doesn't contain colons, but paths might)
		colonPos := strings.LastIndex(pair, ":")
		if colonPos != -1 {
			name := pair[:colonPos]
			hash := pair[colonPos+1:]
			cache[name] = hash
		}
	}

	return cache
}

// comment generates an HTML comment (for errors/debugging).
func (s *Skybolt) comment(text string) string {
	return fmt.Sprintf("<!-- %s -->", html.EscapeString(text))
}
