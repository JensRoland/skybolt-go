// Package skybolt provides high-performance asset caching for multi-page applications.
//
// It reads the render-map.json generated by @skybolt/vite-plugin and outputs
// optimized HTML tags with intelligent caching via Service Workers.
package skybolt

import (
	"encoding/json"
	"fmt"
	"html"
	"net/url"
	"os"
	"strings"
)

// Version is the current version of the Skybolt Go adapter.
const Version = "3.3.0"

// Asset represents a single asset in the render map.
type Asset struct {
	URL     string `json:"url"`
	Hash    string `json:"hash"`
	Size    int    `json:"size"`
	Content string `json:"content"`
}

// LauncherConfig represents the launcher script configuration.
type LauncherConfig struct {
	URL     string `json:"url"`
	Hash    string `json:"hash"`
	Content string `json:"content"`
}

// ServiceWorkerConfig represents the service worker configuration.
type ServiceWorkerConfig struct {
	Filename string `json:"filename"`
	Path     string `json:"path"`
}

// RenderMap represents the complete render map structure.
type RenderMap struct {
	Version        int                 `json:"version"`
	Generated      string              `json:"generated"`
	SkyboltVersion string              `json:"skyboltVersion"`
	BasePath       string              `json:"basePath"`
	Assets         map[string]Asset    `json:"assets"`
	Launcher       LauncherConfig      `json:"launcher"`
	ServiceWorker  ServiceWorkerConfig `json:"serviceWorker"`
}

// urlEntryInfo holds entry and hash for URL lookup.
type urlEntryInfo struct {
	Entry string
	Hash  string
}

// Skybolt is the main struct for rendering assets.
type Skybolt struct {
	renderMap   RenderMap
	clientCache map[string]string
	cdnURL      string
	urlToEntry  map[string]urlEntryInfo // Lazily populated URL to entry mapping
}

// New creates a new Skybolt instance.
//
// renderMapPath is the path to render-map.json generated by the Vite plugin.
// cookies is a map of cookie name to value (can be nil).
// cdnURL is an optional CDN URL prefix (can be empty).
func New(renderMapPath string, cookies map[string]string, cdnURL string) (*Skybolt, error) {
	data, err := os.ReadFile(renderMapPath)
	if err != nil {
		return nil, fmt.Errorf("cannot read render map: %w", err)
	}

	var renderMap RenderMap
	if err := json.Unmarshal(data, &renderMap); err != nil {
		return nil, fmt.Errorf("invalid render map JSON: %w", err)
	}

	// Parse the sb_assets cookie
	clientCache := make(map[string]string)
	if cookies != nil {
		if sbAssets, ok := cookies["sb_assets"]; ok {
			clientCache = parseCookie(sbAssets)
		}
	}

	// Normalize CDN URL
	if cdnURL != "" {
		cdnURL = strings.TrimRight(cdnURL, "/")
	}

	return &Skybolt{
		renderMap:   renderMap,
		clientCache: clientCache,
		cdnURL:      cdnURL,
	}, nil
}

// CSS renders a CSS asset.
//
// On first visit: inlines CSS with sb-* attributes for caching.
// On repeat visit: outputs <link> tag (Service Worker serves from cache).
// If async is true, CSS is loaded in a non-render-blocking way.
func (s *Skybolt) CSS(entry string, async bool) string {
	asset, ok := s.renderMap.Assets[entry]
	if !ok {
		return s.comment(fmt.Sprintf("Skybolt: asset not found: %s", entry))
	}

	assetURL := s.resolveURL(asset.URL)

	// Client has current version - external link (SW serves from cache)
	if s.hasCached(entry, asset.Hash) {
		if async {
			// Preload + onload swap for non-blocking load
			return fmt.Sprintf(
				`<link rel="preload" href="%s" as="style" onload="this.rel='stylesheet'">`+
					`<noscript><link rel="stylesheet" href="%s"></noscript>`,
				html.EscapeString(assetURL),
				html.EscapeString(assetURL),
			)
		}
		return fmt.Sprintf(`<link rel="stylesheet" href="%s">`, html.EscapeString(assetURL))
	}

	// First visit - inline with cache attributes
	if async {
		// media="print" trick: browser parses but doesn't apply until onload swaps to "all"
		return fmt.Sprintf(
			`<style media="print" onload="this.media='all'" sb-asset="%s:%s" sb-url="%s">%s</style>`,
			html.EscapeString(entry),
			html.EscapeString(asset.Hash),
			html.EscapeString(assetURL),
			asset.Content,
		)
	}

	return fmt.Sprintf(
		`<style sb-asset="%s:%s" sb-url="%s">%s</style>`,
		html.EscapeString(entry),
		html.EscapeString(asset.Hash),
		html.EscapeString(assetURL),
		asset.Content,
	)
}

// Script renders a JavaScript asset.
//
// On first visit: inlines JS with sb-* attributes for caching.
// On repeat visit: outputs <script> tag (Service Worker serves from cache).
func (s *Skybolt) Script(entry string, module bool) string {
	asset, ok := s.renderMap.Assets[entry]
	if !ok {
		return s.comment(fmt.Sprintf("Skybolt: asset not found: %s", entry))
	}

	assetURL := s.resolveURL(asset.URL)
	typeAttr := ""
	if module {
		typeAttr = ` type="module"`
	}

	// Client has current version - external script (SW serves from cache)
	if s.hasCached(entry, asset.Hash) {
		return fmt.Sprintf(`<script%s src="%s"></script>`, typeAttr, html.EscapeString(assetURL))
	}

	// First visit - inline with cache attributes
	return fmt.Sprintf(
		`<script%s sb-asset="%s:%s" sb-url="%s">%s</script>`,
		typeAttr,
		html.EscapeString(entry),
		html.EscapeString(asset.Hash),
		html.EscapeString(assetURL),
		asset.Content,
	)
}

// Preload renders a preload link for critical resources.
//
// Use this for fonts, images, or other resources that should load early.
// Preloaded resources are not cached by Skybolt's Service Worker.
func (s *Skybolt) Preload(entry, asType, mimeType, crossorigin, fetchpriority string) string {
	// Try to resolve from assets, fall back to using entry as URL
	assetURL := s.GetAssetURL(entry)
	if assetURL == "" {
		assetURL = entry
	}
	assetURL = s.resolveURL(assetURL)

	attrs := []string{
		`rel="preload"`,
		fmt.Sprintf(`href="%s"`, html.EscapeString(assetURL)),
		fmt.Sprintf(`as="%s"`, html.EscapeString(asType)),
	}

	if mimeType != "" {
		attrs = append(attrs, fmt.Sprintf(`type="%s"`, html.EscapeString(mimeType)))
	}
	if crossorigin != "" {
		attrs = append(attrs, fmt.Sprintf(`crossorigin="%s"`, html.EscapeString(crossorigin)))
	}
	if fetchpriority != "" {
		attrs = append(attrs, fmt.Sprintf(`fetchpriority="%s"`, html.EscapeString(fetchpriority)))
	}

	return fmt.Sprintf("<link %s>", strings.Join(attrs, " "))
}

// LaunchScript renders the Skybolt client launcher.
//
// Call this once in <head> before other Skybolt assets.
// Outputs config meta tag and client script.
//
// On first visit (or cache miss), the launcher is inlined with sb-asset
// and sb-url attributes so the client can cache itself.
//
// On repeat visits (cache hit), returns an external script tag. The Service
// Worker will serve the launcher from cache (~5ms response time).
func (s *Skybolt) LaunchScript() string {
	swPath := s.renderMap.ServiceWorker.Path
	if swPath == "" {
		swPath = "/skybolt-sw.js"
	}

	config := map[string]string{"swPath": swPath}
	configJSON, _ := json.Marshal(config)

	launcher := s.renderMap.Launcher
	launcherURL := s.resolveURL(launcher.URL)

	meta := fmt.Sprintf(`<meta name="skybolt-config" content="%s">`+"\n", html.EscapeString(string(configJSON)))

	if s.hasCached("skybolt-launcher", launcher.Hash) {
		// Repeat visit - external script (SW serves from cache)
		return fmt.Sprintf(`%s<script type="module" src="%s"></script>`, meta, html.EscapeString(launcherURL))
	}

	// First visit - inline with sb-asset and sb-url for self-caching
	return fmt.Sprintf(
		`%s<script type="module" sb-asset="skybolt-launcher:%s" sb-url="%s">%s</script>`,
		meta,
		html.EscapeString(launcher.Hash),
		html.EscapeString(launcherURL),
		launcher.Content,
	)
}

// GetAssetURL returns the URL for an asset (for manual use cases).
// Returns empty string if not found.
func (s *Skybolt) GetAssetURL(entry string) string {
	asset, ok := s.renderMap.Assets[entry]
	if !ok {
		return ""
	}
	return s.resolveURL(asset.URL)
}

// GetAssetHash returns the hash for an asset (for manual use cases).
// Returns empty string if not found.
func (s *Skybolt) GetAssetHash(entry string) string {
	asset, ok := s.renderMap.Assets[entry]
	if !ok {
		return ""
	}
	return asset.Hash
}

// IsCachedURL checks if an asset URL is currently cached by the client.
//
// This is useful for Chain Lightning integration where we need to check
// cache status by URL rather than source path.
func (s *Skybolt) IsCachedURL(assetURL string) bool {
	// Build URL to entry mapping if not already built
	if s.urlToEntry == nil {
		s.urlToEntry = make(map[string]urlEntryInfo)
		for entry, asset := range s.renderMap.Assets {
			s.urlToEntry[asset.URL] = urlEntryInfo{
				Entry: entry,
				Hash:  asset.Hash,
			}
		}
	}

	info, ok := s.urlToEntry[assetURL]
	if !ok {
		return false
	}

	return s.hasCached(info.Entry, info.Hash)
}

// HasCachedEntry checks if client has a specific entry:hash pair cached.
//
// Useful for external integrations (like Chain Lightning) that manage
// their own assets outside of Skybolt's render-map.
func (s *Skybolt) HasCachedEntry(entry, hash string) bool {
	return s.hasCached(entry, hash)
}

// resolveURL resolves a URL with optional CDN prefix.
func (s *Skybolt) resolveURL(assetURL string) string {
	if s.cdnURL == "" {
		return assetURL
	}

	// Don't prefix absolute URLs
	if strings.HasPrefix(assetURL, "http://") ||
		strings.HasPrefix(assetURL, "https://") ||
		strings.HasPrefix(assetURL, "//") {
		return assetURL
	}

	return s.cdnURL + assetURL
}

// hasCached checks if client has a specific asset version cached.
func (s *Skybolt) hasCached(entry, hash string) bool {
	cachedHash, ok := s.clientCache[entry]
	return ok && cachedHash == hash
}

// parseCookie parses the sb_assets cookie into a name => hash map.
func parseCookie(cookie string) map[string]string {
	if cookie == "" {
		return make(map[string]string)
	}

	decoded, err := url.QueryUnescape(cookie)
	if err != nil {
		decoded = cookie
	}

	cache := make(map[string]string)
	for _, pair := range strings.Split(decoded, ",") {
		// Find last colon (hash doesn't contain colons, but paths might)
		colonPos := strings.LastIndex(pair, ":")
		if colonPos != -1 {
			name := pair[:colonPos]
			hash := pair[colonPos+1:]
			cache[name] = hash
		}
	}

	return cache
}

// comment generates an HTML comment (for errors/debugging).
func (s *Skybolt) comment(text string) string {
	return fmt.Sprintf("<!-- %s -->", html.EscapeString(text))
}
